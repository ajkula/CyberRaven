package hmac

import (
	"fmt"
	"strings"
	"time"

	"github.com/ajkula/cyberraven/pkg/sniffer"
)

// Constants for vulnerability types and attack vectors
const (
	// Vulnerability types
	VulnTLSCipherBypass       = "tls_cipher_hmac_bypass"
	VulnTLSSessionReplay      = "tls_session_hmac_replay"
	VulnTLSHandshakeManip     = "tls_handshake_hmac_manipulation"
	VulnTLSPFSCompromise      = "tls_pfs_hmac_compromise"
	VulnTLSWeakKeyForge       = "tls_weak_key_hmac_forge"
	VulnTLSSelfSignedMITM     = "tls_selfsigned_hmac_mitm"
	VulnTLSWeakSigCollision   = "tls_weak_sig_hmac_collision"
	VulnTLSProtocolExploit    = "tls_protocol_hmac_exploit"
	VulnHMACSessionReplay     = "hmac_session_replay_attack"
	VulnHMACMITMRenegotiation = "hmac_mitm_renegotiation"

	// Attack vectors
	AttackCipherWeakness      = "tls_cipher_weakness_exploitation"
	AttackSessionTicketReplay = "session_ticket_hmac_replay"
	AttackHighRiskHandshake   = "tls_high_risk_handshake"
	AttackNoPFS               = "no_perfect_forward_secrecy"
	AttackWeakRSA             = "weak_rsa_factorization"
	AttackSelfSignedMITM      = "self_signed_mitm"
	AttackSignatureCollision  = "signature_collision_attack"
	AttackMITMRenegotiation   = "mitm_renegotiation"

	// Default endpoints
	DefaultHMACEndpoint     = "/api/hmac"
	DefaultAuthEndpoint     = "/api/auth"
	DefaultValidateEndpoint = "/api/validate"
	DefaultSecureEndpoint   = "/api/secure"
)

// Severity levels
var severityRiskMap = map[string]int{
	"critical": 90,
	"high":     80,
	"medium":   60,
	"low":      40,
}

// ExploitTLSIntelligence exploits TLS intelligence for HMAC bypass attacks
func (ht *HMACTester) ExploitTLSIntelligence() {
	if !ht.hasTLSIntelligence() {
		return
	}

	fmt.Printf("[DEBUG] Found %d handshakes to exploit for HMAC attacks\n", len(ht.discoveryCtx.TLSIntelligence.Handshakes))

	// Exploit all TLS intelligence sources
	ht.exploitWeakCiphers()
	ht.exploitVulnerableHandshakes()
	ht.exploitWeakCertificates()
	ht.exploitTLSVulnerabilities()
	ht.exploitAttackSurfaces()
}

// Core exploitation methods

func (ht *HMACTester) exploitWeakCiphers() {
	for _, cipher := range ht.discoveryCtx.TLSIntelligence.WeakCiphers {
		severity, riskScore, description := ht.classifyCipherWeakness(cipher)

		vuln := ht.createVulnerability(VulnTLSCipherBypass, severity, DefaultHMACEndpoint, "POST", description,
			fmt.Sprintf("Weak TLS cipher detected: %s", cipher),
			"Upgrade to strong cipher suites (AES-GCM, ChaCha20-Poly1305) and update HMAC validation",
			riskScore, AttackCipherWeakness)

		vuln.OriginalSignature = "weak_cipher_detected"
		vuln.ForgedSignature = ht.generateBypassSignature(cipher)

		ht.RecordVulnerability(vuln)
	}
}

func (ht *HMACTester) exploitVulnerableHandshakes() {
	for _, handshake := range ht.discoveryCtx.TLSIntelligence.Handshakes {
		ht.exploitSessionTickets(handshake)
		ht.exploitHighRiskHandshake(handshake)
		ht.exploitPFSWeakness(handshake)
	}
}

func (ht *HMACTester) exploitWeakCertificates() {
	for _, cert := range ht.discoveryCtx.TLSIntelligence.Certificates {
		ht.exploitWeakRSAKey(cert)
		ht.exploitSelfSignedCert(cert)
		ht.exploitWeakSignature(cert)
	}
}

func (ht *HMACTester) exploitTLSVulnerabilities() {
	for _, vuln := range ht.discoveryCtx.TLSIntelligence.Vulnerabilities {
		if vuln.Severity == "high" || vuln.Severity == "critical" {
			v := ht.createVulnerability(VulnTLSProtocolExploit, vuln.Severity, DefaultSecureEndpoint, "POST",
				fmt.Sprintf("TLS vulnerability (%s) enables HMAC bypass: %s", vuln.Name, vuln.Description),
				vuln.Evidence,
				fmt.Sprintf("Fix TLS vulnerability and review HMAC implementation: %s", vuln.Remediation),
				severityRiskMap[vuln.Severity], fmt.Sprintf("tls_%s_exploitation", vuln.Name))

			ht.RecordVulnerability(v)
		}
	}
}

func (ht *HMACTester) exploitAttackSurfaces() {
	for _, handshake := range ht.discoveryCtx.TLSIntelligence.Handshakes {
		for _, attackVector := range handshake.AttackSurface {
			ht.exploitSpecificAttackSurface(attackVector, handshake)
		}
	}
}

// Specific exploitation methods

func (ht *HMACTester) exploitSessionTickets(handshake sniffer.TLSHandshake) {
	if !handshake.SessionTickets {
		return
	}

	vuln := ht.createVulnerability(VulnTLSSessionReplay, "high", DefaultAuthEndpoint, "GET",
		"TLS session tickets enable HMAC signature replay attacks",
		fmt.Sprintf("Risk score: %.0f, Session tickets enabled", handshake.RiskScore),
		"Disable session tickets and implement HMAC timestamp validation",
		85, AttackSessionTicketReplay)

	now := time.Now()
	vuln.TimestampUsed = &now

	ht.RecordVulnerability(vuln)
}

func (ht *HMACTester) exploitHighRiskHandshake(handshake sniffer.TLSHandshake) {
	if handshake.RiskScore <= 50 {
		return
	}

	vuln := ht.createVulnerability(VulnTLSHandshakeManip, "critical", DefaultAuthEndpoint, "POST",
		fmt.Sprintf("High-risk TLS handshake (score: %.0f) allows HMAC signature manipulation", handshake.RiskScore),
		fmt.Sprintf("Vulnerabilities: %v, Cipher: %s", handshake.VulnerableToAttacks, handshake.CipherSuite),
		"Upgrade TLS configuration and implement stronger HMAC validation",
		int(handshake.RiskScore), AttackHighRiskHandshake)

	vuln.Algorithm = handshake.CipherSuite

	ht.RecordVulnerability(vuln)
}

func (ht *HMACTester) exploitPFSWeakness(handshake sniffer.TLSHandshake) {
	if handshake.PerfectForwardSecrecy {
		return
	}

	vuln := ht.createVulnerability(VulnTLSPFSCompromise, "medium", DefaultAuthEndpoint, "GET",
		"Lack of Perfect Forward Secrecy exposes HMAC keys to future compromise",
		fmt.Sprintf("No PFS in cipher: %s", handshake.CipherSuite),
		"Enable PFS cipher suites and rotate HMAC keys regularly",
		70, AttackNoPFS)

	vuln.Algorithm = handshake.CipherSuite

	ht.RecordVulnerability(vuln)
}

func (ht *HMACTester) exploitWeakRSAKey(cert sniffer.CapturedCertificate) {
	if !cert.IsWeakKey || cert.KeySize >= 2048 {
		return
	}

	vuln := ht.createVulnerability(VulnTLSWeakKeyForge, "critical", DefaultValidateEndpoint, "POST",
		fmt.Sprintf("Weak RSA key (%d bits) allows HMAC signature forgery through factorization", cert.KeySize),
		fmt.Sprintf("Certificate: %s, Key size: %d bits", cert.Subject, cert.KeySize),
		"Use RSA keys â‰¥2048 bits and implement certificate pinning",
		95, AttackWeakRSA)

	vuln.OriginalSignature = "weak_key_detected"
	vuln.ForgedSignature = ht.generateWeakKeySignature(cert.KeySize)

	ht.RecordVulnerability(vuln)
}

func (ht *HMACTester) exploitSelfSignedCert(cert sniffer.CapturedCertificate) {
	if !cert.IsSelfSigned {
		return
	}

	vuln := ht.createVulnerability(VulnTLSSelfSignedMITM, "high", DefaultValidateEndpoint, "GET",
		"Self-signed certificate enables MITM attacks on HMAC validation",
		fmt.Sprintf("Self-signed certificate: %s", cert.Subject),
		"Use properly signed certificates and implement certificate validation",
		80, AttackSelfSignedMITM)

	ht.RecordVulnerability(vuln)
}

func (ht *HMACTester) exploitWeakSignature(cert sniffer.CapturedCertificate) {
	if !cert.IsWeakSignature {
		return
	}

	vuln := ht.createVulnerability(VulnTLSWeakSigCollision, "high", DefaultValidateEndpoint, "POST",
		fmt.Sprintf("Weak signature algorithm (%s) vulnerable to collision attacks affecting HMAC", cert.SignatureAlg),
		fmt.Sprintf("Weak signature: %s", cert.SignatureAlg),
		"Upgrade to SHA-256 or better signature algorithms",
		75, AttackSignatureCollision)

	vuln.Algorithm = cert.SignatureAlg

	ht.RecordVulnerability(vuln)
}

func (ht *HMACTester) exploitSpecificAttackSurface(attackVector string, handshake sniffer.TLSHandshake) {
	switch attackVector {
	case "session_ticket_replay":
		vuln := ht.createVulnerability(VulnHMACSessionReplay, "high", DefaultHMACEndpoint, "POST",
			"Session ticket replay enables HMAC signature reuse attacks",
			fmt.Sprintf("Handshake ID: %s, Session tickets enabled", handshake.ID),
			"Implement session binding and HMAC nonce validation",
			85, AttackSessionTicketReplay)

		ht.RecordVulnerability(vuln)

	case "mitm_renegotiation":
		vuln := ht.createVulnerability(VulnHMACMITMRenegotiation, "critical", DefaultHMACEndpoint, "GET",
			"TLS renegotiation MITM attack allows HMAC signature interception",
			fmt.Sprintf("Client: %s, Server: %s", handshake.ClientIP, handshake.ServerIP),
			"Disable insecure renegotiation and use HMAC over secure channels only",
			90, AttackMITMRenegotiation)

		ht.RecordVulnerability(vuln)
	}
}

// Helper methods

func (ht *HMACTester) hasTLSIntelligence() bool {
	if ht.discoveryCtx == nil || ht.discoveryCtx.TLSIntelligence.TotalHandshakes == 0 {
		fmt.Println("[DEBUG] No TLS intelligence available for HMAC exploitation")
		return false
	}
	return true
}

func (ht *HMACTester) getTargetEndpoint(defaultEndpoint string) string {
	if endpoints := ht.GetIntelligentEndpoints(); len(endpoints) > 0 {
		return endpoints[0]
	}
	return defaultEndpoint
}

func (ht *HMACTester) createVulnerability(vulnType, severity, endpoint, method, description, evidence, remediation string, riskScore int, attackVector string) HMACVulnerability {
	return HMACVulnerability{
		Type:         vulnType,
		Severity:     severity,
		Endpoint:     ht.getTargetEndpoint(endpoint),
		Method:       method,
		Description:  description,
		Evidence:     evidence,
		Remediation:  remediation,
		RiskScore:    riskScore,
		Algorithm:    ht.target.Auth.HMAC.Algorithm,
		AttackVector: attackVector,
		ResponseTime: 0,
	}
}

func (ht *HMACTester) classifyCipherWeakness(cipher string) (severity string, riskScore int, description string) {
	cipherUpper := strings.ToUpper(cipher)

	switch {
	case ht.containsCipher(cipherUpper, "RC4"):
		return "critical", 95, fmt.Sprintf("RC4 cipher (%s) allows HMAC signature prediction through keystream bias", cipher)
	case ht.containsCipher(cipherUpper, "DES") || ht.containsCipher(cipherUpper, "EXPORT"):
		return "critical", 90, fmt.Sprintf("Weak cipher (%s) enables HMAC key extraction through cryptanalysis", cipher)
	case ht.containsCipher(cipherUpper, "MD5"):
		return "high", 80, fmt.Sprintf("MD5-based cipher (%s) vulnerable to collision attacks affecting HMAC integrity", cipher)
	default:
		return "medium", 60, fmt.Sprintf("Deprecated cipher (%s) may allow HMAC signature manipulation", cipher)
	}
}

func (ht *HMACTester) containsCipher(cipher, pattern string) bool {
	return strings.Contains(cipher, pattern)
}

func (ht *HMACTester) generateBypassSignature(cipher string) string {
	return fmt.Sprintf("bypass_%s_%d", cipher, time.Now().Unix())
}

func (ht *HMACTester) generateWeakKeySignature(keySize int) string {
	return fmt.Sprintf("weak_key_forge_%d_bits", keySize)
}
