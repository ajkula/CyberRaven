package tls

import (
	"fmt"
	"strings"

	"github.com/ajkula/cyberraven/pkg/sniffer"
)

// Constants for TLS exploitation types
const (
	// Vulnerability types
	VulnTLSDowngradeAttack     = "tls_protocol_downgrade_attack"
	VulnTLSCipherDowngrade     = "tls_cipher_suite_downgrade"
	VulnTLSCertificateSpoofing = "tls_certificate_spoofing_attack"
	VulnTLSRenegotiationAttack = "tls_renegotiation_attack"
	VulnTLSCompressionAttack   = "tls_compression_attack"
	VulnTLSSessionHijacking    = "tls_session_hijacking"
	VulnTLSWeakRandomness      = "tls_weak_randomness_exploit"
	VulnTLSHeartbleedExploit   = "tls_heartbleed_exploit"
	VulnTLSBeastAttack         = "tls_beast_attack"
	VulnTLSPoodleAttack        = "tls_poodle_attack"

	// Severity mappings
	SeverityCritical = "critical"
	SeverityHigh     = "high"
	SeverityMedium   = "medium"
	SeverityLow      = "low"
)

// Severity to risk score mapping
var tlsSeverityRiskMap = map[string]int{
	SeverityCritical: 95,
	SeverityHigh:     85,
	SeverityMedium:   70,
	SeverityLow:      50,
}

// ExploitTLSIntelligence exploits captured TLS intelligence for direct TLS attacks
func (tt *TLSTester) ExploitTLSIntelligence() {
	fmt.Println("[DEBUG] TLS ExploitTLSIntelligence called")

	if !tt.hasTLSIntelligence() {
		return
	}

	fmt.Printf("[DEBUG] Found %d handshakes to exploit for TLS attacks\n", len(tt.discoveryCtx.TLSIntelligence.Handshakes))

	// Direct TLS exploitation strategies
	tt.exploitProtocolDowngrade()
	tt.exploitWeakCipherSuites()
	tt.exploitCertificateWeaknesses()
	tt.exploitHandshakeVulnerabilities()
	tt.exploitTLSProtocolVulnerabilities()
	tt.exploitAttackSurfaces()
}

// Core exploitation methods

func (tt *TLSTester) exploitProtocolDowngrade() {
	for _, handshake := range tt.discoveryCtx.TLSIntelligence.Handshakes {
		tt.exploitVersionDowngrade(handshake)
		tt.exploitCipherDowngrade(handshake)
	}
}

func (tt *TLSTester) exploitWeakCipherSuites() {
	for _, cipher := range tt.discoveryCtx.TLSIntelligence.WeakCiphers {
		tt.exploitSpecificCipher(cipher)
	}
}

func (tt *TLSTester) exploitCertificateWeaknesses() {
	for _, cert := range tt.discoveryCtx.TLSIntelligence.Certificates {
		tt.exploitCertificateSpoof(cert)
		tt.exploitWeakCertificateKey(cert)
		tt.exploitCertificateValidation(cert)
	}
}

func (tt *TLSTester) exploitHandshakeVulnerabilities() {
	for _, handshake := range tt.discoveryCtx.TLSIntelligence.Handshakes {
		tt.exploitRenegotiationWeakness(handshake)
		tt.exploitSessionManagement(handshake)
		tt.exploitCompressionWeakness(handshake)
	}
}

func (tt *TLSTester) exploitTLSProtocolVulnerabilities() {
	for _, vuln := range tt.discoveryCtx.TLSIntelligence.Vulnerabilities {
		if vuln.Severity == SeverityHigh || vuln.Severity == SeverityCritical {
			tt.exploitProtocolVulnerability(vuln)
		}
	}
}

func (tt *TLSTester) exploitAttackSurfaces() {
	for _, handshake := range tt.discoveryCtx.TLSIntelligence.Handshakes {
		for _, attackVector := range handshake.AttackSurface {
			tt.exploitSpecificAttackSurface(attackVector, handshake)
		}
	}
}

// Specific exploitation methods

func (tt *TLSTester) exploitVersionDowngrade(handshake sniffer.TLSHandshake) {
	if handshake.ClientVersion != handshake.ServerVersion {
		severity := tt.classifyVersionDowngrade(handshake.ServerVersion)

		vuln := tt.createTLSVulnerability(VulnTLSDowngradeAttack, severity, "protocol",
			fmt.Sprintf("Protocol downgrade from %s to %s detected", handshake.ClientVersion, handshake.ServerVersion),
			fmt.Sprintf("Client requested: %s, Server negotiated: %s", handshake.ClientVersion, handshake.ServerVersion),
			"Disable support for weak TLS versions and enforce minimum TLS 1.2",
			tlsSeverityRiskMap[severity], handshake.ServerVersion, "", "")

		tt.recordVulnerability(vuln)
	}
}

func (tt *TLSTester) exploitCipherDowngrade(handshake sniffer.TLSHandshake) {
	if handshake.WeakCipher {
		vuln := tt.createTLSVulnerability(VulnTLSCipherDowngrade, SeverityHigh, "cipher",
			fmt.Sprintf("Weak cipher suite negotiated: %s", handshake.CipherSuite),
			fmt.Sprintf("Cipher suite: %s, PFS: %t", handshake.CipherSuite, handshake.PerfectForwardSecrecy),
			"Configure server to prefer strong cipher suites with PFS",
			85, handshake.NegotiatedVersion, handshake.CipherSuite, "")

		tt.recordVulnerability(vuln)
	}
}

func (tt *TLSTester) exploitSpecificCipher(cipher string) {
	severity, description, remediation := tt.classifyCipherExploit(cipher)

	vuln := tt.createTLSVulnerability(VulnTLSCipherDowngrade, severity, "cipher",
		description,
		fmt.Sprintf("Vulnerable cipher suite detected: %s", cipher),
		remediation,
		tlsSeverityRiskMap[severity], "", cipher, "")

	tt.recordVulnerability(vuln)
}

func (tt *TLSTester) exploitCertificateSpoof(cert sniffer.CapturedCertificate) {
	if cert.IsSelfSigned {
		vuln := tt.createTLSVulnerability(VulnTLSCertificateSpoofing, SeverityHigh, "certificate",
			"Self-signed certificate allows certificate spoofing attacks",
			fmt.Sprintf("Self-signed certificate: %s", cert.Subject),
			"Use certificates signed by trusted CA and implement certificate pinning",
			80, "", "", cert.Fingerprint)

		tt.recordVulnerability(vuln)
	}
}

func (tt *TLSTester) exploitWeakCertificateKey(cert sniffer.CapturedCertificate) {
	if cert.IsWeakKey && cert.KeySize < 2048 {
		vuln := tt.createTLSVulnerability(VulnTLSCertificateSpoofing, SeverityCritical, "certificate",
			fmt.Sprintf("Weak RSA key (%d bits) vulnerable to factorization attacks", cert.KeySize),
			fmt.Sprintf("Certificate: %s, Key size: %d bits", cert.Subject, cert.KeySize),
			"Use RSA keys ≥2048 bits or ECDSA keys ≥256 bits",
			95, "", "", cert.Fingerprint)

		tt.recordVulnerability(vuln)
	}
}

func (tt *TLSTester) exploitCertificateValidation(cert sniffer.CapturedCertificate) {
	if cert.IsWeakSignature {
		vuln := tt.createTLSVulnerability(VulnTLSCertificateSpoofing, SeverityHigh, "certificate",
			fmt.Sprintf("Weak signature algorithm (%s) vulnerable to collision attacks", cert.SignatureAlg),
			fmt.Sprintf("Signature algorithm: %s", cert.SignatureAlg),
			"Upgrade to SHA-256 or stronger signature algorithms",
			75, "", "", cert.Fingerprint)

		tt.recordVulnerability(vuln)
	}
}

func (tt *TLSTester) exploitRenegotiationWeakness(handshake sniffer.TLSHandshake) {
	if tt.containsAttack(handshake.VulnerableToAttacks, "insecure_renegotiation") {
		vuln := tt.createTLSVulnerability(VulnTLSRenegotiationAttack, SeverityCritical, "protocol",
			"Insecure TLS renegotiation allows MITM attacks",
			fmt.Sprintf("Handshake supports insecure renegotiation: %s", handshake.ID),
			"Disable insecure renegotiation and implement RFC 5746",
			90, handshake.NegotiatedVersion, handshake.CipherSuite, "")

		tt.recordVulnerability(vuln)
	}
}

func (tt *TLSTester) exploitSessionManagement(handshake sniffer.TLSHandshake) {
	if handshake.SessionTickets {
		vuln := tt.createTLSVulnerability(VulnTLSSessionHijacking, SeverityHigh, "protocol",
			"TLS session tickets enable session replay and hijacking attacks",
			fmt.Sprintf("Session tickets enabled for handshake: %s", handshake.ID),
			"Disable session tickets or implement proper session binding",
			80, handshake.NegotiatedVersion, "", "")

		tt.recordVulnerability(vuln)
	}
}

func (tt *TLSTester) exploitCompressionWeakness(handshake sniffer.TLSHandshake) {
	if tt.containsAttack(handshake.VulnerableToAttacks, "crime_compression") {
		vuln := tt.createTLSVulnerability(VulnTLSCompressionAttack, SeverityMedium, "protocol",
			"TLS compression enables CRIME/BREACH attacks",
			fmt.Sprintf("Compression detected in handshake: %s", handshake.ID),
			"Disable TLS compression to prevent CRIME attacks",
			70, handshake.NegotiatedVersion, "", "")

		tt.recordVulnerability(vuln)
	}
}

func (tt *TLSTester) exploitProtocolVulnerability(vuln sniffer.TLSVulnerability) {
	exploitType := tt.mapVulnerabilityToExploit(vuln.Type)

	tlsVuln := tt.createTLSVulnerability(exploitType, vuln.Severity, "protocol",
		fmt.Sprintf("TLS protocol vulnerability: %s - %s", vuln.Name, vuln.Description),
		vuln.Evidence,
		fmt.Sprintf("Fix TLS protocol issue: %s", vuln.Remediation),
		tlsSeverityRiskMap[vuln.Severity], "", "", "")

	tt.recordVulnerability(tlsVuln)
}

func (tt *TLSTester) exploitSpecificAttackSurface(attackVector string, handshake sniffer.TLSHandshake) {
	switch attackVector {
	case "renegotiation_attack":
		vuln := tt.createTLSVulnerability(VulnTLSRenegotiationAttack, SeverityCritical, "protocol",
			"TLS renegotiation attack surface exposed",
			fmt.Sprintf("Renegotiation attack possible on handshake: %s", handshake.ID),
			"Implement secure renegotiation (RFC 5746)",
			90, handshake.NegotiatedVersion, "", "")

		tt.recordVulnerability(vuln)

	case "session_ticket_replay":
		vuln := tt.createTLSVulnerability(VulnTLSSessionHijacking, SeverityHigh, "protocol",
			"Session ticket replay attack possible",
			fmt.Sprintf("Session tickets vulnerable to replay: %s", handshake.ID),
			"Implement session ticket encryption and rotation",
			85, handshake.NegotiatedVersion, "", "")

		tt.recordVulnerability(vuln)

	case "compression_attack":
		vuln := tt.createTLSVulnerability(VulnTLSCompressionAttack, SeverityMedium, "protocol",
			"TLS compression attack surface exposed",
			fmt.Sprintf("Compression attack possible: %s", handshake.ID),
			"Disable TLS compression",
			70, handshake.NegotiatedVersion, "", "")

		tt.recordVulnerability(vuln)

	case "mitm_renegotiation":
		vuln := tt.createTLSVulnerability(VulnTLSRenegotiationAttack, SeverityCritical, "protocol",
			"MITM renegotiation attack surface",
			fmt.Sprintf("MITM renegotiation possible: Client %s, Server %s", handshake.ClientIP, handshake.ServerIP),
			"Disable insecure renegotiation",
			95, handshake.NegotiatedVersion, "", "")

		tt.recordVulnerability(vuln)
	}
}

// Helper methods

func (tt *TLSTester) hasTLSIntelligence() bool {
	if tt.discoveryCtx == nil || tt.discoveryCtx.TLSIntelligence.TotalHandshakes == 0 {
		fmt.Println("[DEBUG] No TLS intelligence available for TLS exploitation")
		return false
	}
	return true
}

func (tt *TLSTester) createTLSVulnerability(vulnType, severity, component, description, evidence, remediation string, riskScore int, tlsVersion, cipherSuite, certID string) TLSVulnerability {
	return TLSVulnerability{
		Type:          vulnType,
		Severity:      severity,
		Component:     component,
		Description:   description,
		Evidence:      evidence,
		Remediation:   remediation,
		RiskScore:     riskScore,
		TLSVersion:    tlsVersion,
		CipherSuite:   cipherSuite,
		CertificateID: certID,
		Exploitable:   true, // Intelligence-based exploits are by definition exploitable
	}
}

func (tt *TLSTester) recordVulnerability(vuln TLSVulnerability) {
	tt.mu.Lock()
	tt.vulnerabilities = append(tt.vulnerabilities, vuln)
	tt.mu.Unlock()
}

func (tt *TLSTester) classifyVersionDowngrade(version string) string {
	switch {
	case strings.Contains(version, "SSL"):
		return SeverityCritical
	case strings.Contains(version, "TLS 1.0") || strings.Contains(version, "TLS 1.1"):
		return SeverityHigh
	case strings.Contains(version, "TLS 1.2"):
		return SeverityMedium
	default:
		return SeverityLow
	}
}

func (tt *TLSTester) classifyCipherExploit(cipher string) (severity, description, remediation string) {
	cipherUpper := strings.ToUpper(cipher)

	switch {
	case strings.Contains(cipherUpper, "RC4"):
		return SeverityCritical,
			fmt.Sprintf("RC4 cipher (%s) vulnerable to biased keystream attacks", cipher),
			"Remove RC4 cipher suites from server configuration"

	case strings.Contains(cipherUpper, "DES") || strings.Contains(cipherUpper, "EXPORT"):
		return SeverityCritical,
			fmt.Sprintf("Export-grade cipher (%s) vulnerable to brute force attacks", cipher),
			"Remove all export-grade and DES cipher suites"

	case strings.Contains(cipherUpper, "MD5"):
		return SeverityHigh,
			fmt.Sprintf("MD5-based cipher (%s) vulnerable to collision attacks", cipher),
			"Upgrade to SHA-256 or stronger hash functions"

	case strings.Contains(cipherUpper, "CBC"):
		return SeverityMedium,
			fmt.Sprintf("CBC cipher (%s) potentially vulnerable to padding oracle attacks", cipher),
			"Prefer AEAD cipher suites (GCM, ChaCha20-Poly1305)"

	default:
		return SeverityLow,
			fmt.Sprintf("Deprecated cipher (%s) should be replaced", cipher),
			"Update to modern cipher suites"
	}
}

func (tt *TLSTester) mapVulnerabilityToExploit(vulnType string) string {
	switch vulnType {
	case "change_cipher_spec_received":
		return VulnTLSRenegotiationAttack
	case "premature_cipher_change":
		return VulnTLSDowngradeAttack
	default:
		return "tls_protocol_vulnerability"
	}
}

func (tt *TLSTester) containsAttack(attacks []string, target string) bool {
	for _, attack := range attacks {
		if attack == target {
			return true
		}
	}
	return false
}
