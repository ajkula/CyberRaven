package jwt

import (
	"fmt"

	"github.com/ajkula/cyberraven/pkg/discovery"
	"github.com/ajkula/cyberraven/pkg/sniffer"
)

func (j *JWTFuzzer) ExploitTLSIntelligence(attackContext *discovery.AttackContext) {
	if attackContext == nil || attackContext.TLSIntelligence.TotalHandshakes == 0 {
		return
	}

	for _, cert := range attackContext.TLSIntelligence.Certificates {
		j.exploitCertificate(cert)
	}
}

func (j *JWTFuzzer) exploitCertificate(cert sniffer.CapturedCertificate) {
	if cert.IsWeakKey && cert.KeySize < 2048 {
		j.generateWeakKeyJWT(cert)
	}
	if cert.IsSelfSigned {
		j.generateSelfSignedJWT(cert)
	}
	if cert.IsWeakSignature {
		j.generateWeakSigJWT(cert)
	}
}

func (j *JWTFuzzer) generateWeakKeyJWT(cert sniffer.CapturedCertificate) {
	maliciousToken := fmt.Sprintf(`eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImlzcyI6InRscy1leHBsb2l0Iiwia2V5X3NpemUiOiVkfQ.weak_rsa_signature`, cert.KeySize)

	vuln := JWTVulnerability{
		Type:           "weak_rsa_exploitation",
		Severity:       "critical",
		Description:    fmt.Sprintf("Weak RSA key (%d bits) from TLS certificate", cert.KeySize),
		Evidence:       fmt.Sprintf("Certificate subject: %s, Key size: %d", cert.Subject, cert.KeySize),
		MaliciousToken: maliciousToken,
		AttackVector:   "tls_weak_key_factorization",
		Endpoint:       "/",
		Method:         "GET",
		RiskScore:      95,
	}

	j.mu.Lock()
	j.vulnerabilities = append(j.vulnerabilities, vuln)
	j.mu.Unlock()
}

func (j *JWTFuzzer) generateSelfSignedJWT(cert sniffer.CapturedCertificate) {
	maliciousToken := `eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImlzcyI6InNlbGYtc2lnbmVkLWV4cGxvaXQifQ.self_signed_signature`

	vuln := JWTVulnerability{
		Type:           "self_signed_exploitation",
		Severity:       "high",
		Description:    "Self-signed certificate exploitation for JWT forgery",
		Evidence:       fmt.Sprintf("Self-signed certificate: %s", cert.Subject),
		MaliciousToken: maliciousToken,
		AttackVector:   "tls_self_signed_mitm",
		Endpoint:       "/",
		Method:         "GET",
		RiskScore:      85,
	}

	j.mu.Lock()
	j.vulnerabilities = append(j.vulnerabilities, vuln)
	j.mu.Unlock()
}

func (j *JWTFuzzer) generateWeakSigJWT(cert sniffer.CapturedCertificate) {
	maliciousToken := `eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImlzcyI6IndlYWstc2lnLWV4cGxvaXQifQ.weak_signature`

	vuln := JWTVulnerability{
		Type:           "weak_signature_exploitation",
		Severity:       "high",
		Description:    fmt.Sprintf("Weak signature algorithm (%s) exploitation", cert.SignatureAlg),
		Evidence:       fmt.Sprintf("Weak signature algorithm: %s", cert.SignatureAlg),
		MaliciousToken: maliciousToken,
		AttackVector:   "tls_weak_signature_forge",
		Endpoint:       "/",
		Method:         "GET",
		RiskScore:      80,
	}

	j.mu.Lock()
	j.vulnerabilities = append(j.vulnerabilities, vuln)
	j.mu.Unlock()
}
