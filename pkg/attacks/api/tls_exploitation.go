package api

import (
	"fmt"

	"github.com/ajkula/cyberraven/pkg/sniffer"
)

func (e *Enumerator) ExploitTLSIntelligence(resultCollector *ResultCollector) {
	fmt.Println("[DEBUG] ExploitTLSIntelligence called")

	if e.discoveryCtx == nil || e.discoveryCtx.TLSIntelligence.TotalHandshakes == 0 {
		fmt.Println("[DEBUG] No TLS intelligence available")
		return
	}

	fmt.Printf("[DEBUG] Found %d handshakes to exploit\n", len(e.discoveryCtx.TLSIntelligence.Handshakes))

	// Session hijacking
	for _, handshake := range e.discoveryCtx.TLSIntelligence.Handshakes {
		e.exploitVulnerableHandshake(handshake, resultCollector)
	}

	// Client spoofing
	for _, vuln := range e.discoveryCtx.TLSIntelligence.Vulnerabilities {
		e.exploitTLSVulnerability(vuln, resultCollector)
	}

	// MITM exploitation
	for _, handshake := range e.discoveryCtx.TLSIntelligence.Handshakes {
		for _, attackVector := range handshake.AttackSurface {
			e.exploitAttackSurface(attackVector, handshake, resultCollector)
		}
	}
}

func (e *Enumerator) exploitVulnerableHandshake(handshake sniffer.TLSHandshake, resultCollector *ResultCollector) {
	if handshake.SessionTickets {
		targetEndpoints := e.getTargetedEndpoints()
		endpoint := "/api/session"
		if len(targetEndpoints) > 0 {
			endpoint = targetEndpoints[0]
		}

		vulnerability := VulnerabilityFinding{
			Type:        "tls_session_ticket_exploitation",
			Severity:    "high",
			Endpoint:    endpoint,
			Method:      "GET",
			Description: "TLS session tickets enabled - session replay possible",
			Evidence:    fmt.Sprintf("Risk score: %.0f, Cipher: %s", handshake.RiskScore, handshake.CipherSuite),
			Remediation: "Disable session tickets or implement proper validation",
		}
		resultCollector.RecordVulnerability(vulnerability)
	}

	if handshake.RiskScore > 50 {
		vulnerability := VulnerabilityFinding{
			Type:        "tls_high_risk_handshake",
			Severity:    "critical",
			Endpoint:    "/api/secure",
			Method:      "POST",
			Description: fmt.Sprintf("High-risk TLS handshake detected (score: %.0f)", handshake.RiskScore),
			Evidence:    fmt.Sprintf("Vulnerabilities: %v", handshake.VulnerableToAttacks),
			Remediation: "Upgrade TLS configuration and cipher suites",
		}
		resultCollector.RecordVulnerability(vulnerability)
	}
}

func (e *Enumerator) exploitTLSVulnerability(vuln sniffer.TLSVulnerability, resultCollector *ResultCollector) {
	if vuln.Severity == "high" || vuln.Severity == "critical" {
		vulnerability := VulnerabilityFinding{
			Type:        "tls_protocol_vulnerability",
			Severity:    vuln.Severity,
			Endpoint:    "/api/vulnerable",
			Method:      "GET",
			Description: fmt.Sprintf("TLS vulnerability: %s - %s", vuln.Name, vuln.Description),
			Evidence:    vuln.Evidence,
			Remediation: vuln.Remediation,
		}
		resultCollector.RecordVulnerability(vulnerability)
	}
}

func (e *Enumerator) exploitAttackSurface(attackVector string, handshake sniffer.TLSHandshake, resultCollector *ResultCollector) {
	switch attackVector {
	case "session_ticket_replay":
		vulnerability := VulnerabilityFinding{
			Type:        "tls_session_replay_attack",
			Severity:    "high",
			Endpoint:    "/api/replay",
			Method:      "POST",
			Description: "Session ticket replay attack possible",
			Evidence:    fmt.Sprintf("Handshake ID: %s", handshake.ID),
			Remediation: "Implement session binding",
		}
		resultCollector.RecordVulnerability(vulnerability)
	case "mitm_renegotiation":
		vulnerability := VulnerabilityFinding{
			Type:        "tls_mitm_renegotiation",
			Severity:    "critical",
			Endpoint:    "/api/mitm",
			Method:      "GET",
			Description: "TLS renegotiation MITM attack possible",
			Evidence:    fmt.Sprintf("Client: %s, Server: %s", handshake.ClientIP, handshake.ServerIP),
			Remediation: "Disable insecure renegotiation",
		}
		resultCollector.RecordVulnerability(vulnerability)
	}
}
